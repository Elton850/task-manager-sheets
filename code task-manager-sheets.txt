const SHEETS = {
  USERS: 'USERS',
  TASKS: 'TASKS',
  LOOKUPS: 'LOOKUPS',
  LOGS: 'LOGS',
};

function doGet() {
  return ContentService.createTextOutput('OK').setMimeType(ContentService.MimeType.TEXT);
}

function doPost(e) {
  try {
    const body = e && e.postData && e.postData.contents ? JSON.parse(e.postData.contents) : {};
    const apiKey = String(body.apiKey || '').trim();
    const expected = PropertiesService.getScriptProperties().getProperty('API_KEY');
    if (!expected || apiKey !== expected) return _json({ ok: false, error: 'UNAUTHORIZED' }, 401);

    const action = String(body.action || '').trim();
    if (!action) return _json({ ok: false, error: 'Missing action' }, 400);

    switch (action) {
      case 'users.list':
        return _json({ ok: true, users: usersList() });

      case 'users.upsert':
        return _json({ ok: true, user: usersUpsert(body.user, body.actorEmail) });

      case 'users.setActive':
        return _json({ ok: true, user: usersSetActive(body.email, body.active, body.actorEmail) });

      case 'ping':
        return _json({ ok: true });

      case 'users.getByEmail':
        return _json({ ok: true, user: usersGetByEmail(body.email) });

      case 'tasks.list':
        return _json({ ok: true, tasks: tasksList() });

      case 'tasks.create':
        return _json({ ok: true, task: tasksCreate(body.task) });

      case 'tasks.update':
        return _json({ ok: true, task: tasksUpdate(body.id, body.patch) });

      case 'tasks.softDelete':
        return _json({ ok: true, task: tasksSoftDelete(body.id, body.deletedBy) });

      case 'lookups.list':
        return _json({ ok: true, lookups: lookupsList() });

      case 'lookups.upsert':
        return _json({ ok: true, lookups: lookupsUpsert(body.item) });

      case 'lookups.rename':
        return _json({ ok: true, lookups: lookupsRename(body.category, body.oldValue, body.newValue, body.actorEmail) });

      default:
        return _json({ ok: false, error: 'Unknown action' }, 400);
    }
  } catch (err) {
    return _json({ ok: false, error: String(err && err.message ? err.message : err) }, 500);
  }
}

function _ss() { return SpreadsheetApp.getActive(); }
function _sheet(name) {
  const sh = _ss().getSheetByName(name);
  if (!sh) throw new Error('Aba não encontrada: ' + name);
  return sh;
}
function _readAll(sh) {
  const lr = sh.getLastRow();
  const lc = sh.getLastColumn();
  const headers = lc ? sh.getRange(1, 1, 1, lc).getValues()[0].map(String) : [];
  if (lr < 2) return { headers, rows: [] };
  const rows = sh.getRange(2, 1, lr - 1, lc).getValues();
  return { headers, rows };
}
function _rowsToObjects(headers, rows) {
  return rows.map(r => {
    const o = {};
    headers.forEach((h, i) => o[h] = r[i]);
    return o;
  });
}
function _headerMap(sh) {
  const lc = sh.getLastColumn();
  const headers = sh.getRange(1, 1, 1, lc).getValues()[0].map(String);
  const map = {};
  headers.forEach((h, i) => map[h] = i + 1);
  return map;
}
function _nowIso() { return new Date().toISOString(); }

function _json(obj, code) {
  const out = ContentService.createTextOutput(JSON.stringify(obj));
  out.setMimeType(ContentService.MimeType.JSON);
  // ContentService não permite setar status code diretamente; retorna no body.
  return out;
}

function _log(actorEmail, action, entity, entityId, beforeObj, afterObj) {
  const sh = _sheet(SHEETS.LOGS);
  sh.appendRow([
    new Date(),
    actorEmail || '',
    action || '',
    entity || '',
    entityId || '',
    beforeObj ? JSON.stringify(beforeObj).slice(0, 40000) : '',
    afterObj ? JSON.stringify(afterObj).slice(0, 40000) : '',
  ]);
}

/* USERS */
function usersGetByEmail(email) {
  const sh = _sheet(SHEETS.USERS);
  const { headers, rows } = _readAll(sh);
  const objs = _rowsToObjects(headers, rows);
  const e = String(email || '').toLowerCase();
  const u = objs.find(x => String(x.email || '').toLowerCase() === e);
  return u || null;
}

function usersList() {
  const sh = _sheet(SHEETS.USERS);
  const { headers, rows } = _readAll(sh);
  const objs = _rowsToObjects(headers, rows);

  return objs.map(u => ({
    email: String(u.email || '').toLowerCase(),
    nome: String(u.nome || ''),
    role: String(u.role || 'USER').toUpperCase(),
    area: String(u.area || ''),
    active: String(u.active || '').toUpperCase() === 'TRUE',
    canDelete: String(u.canDelete || '').toUpperCase() === 'TRUE',

    // opcional (não sensível)
    mustChangePassword: String(u.mustChangePassword || '').toUpperCase() === 'TRUE',
  }));
}

function usersUpsert(user, actorEmail) {
  const sh = _sheet(SHEETS.USERS);
  const map = _headerMap(sh);
  const { headers, rows } = _readAll(sh);
  const objs = _rowsToObjects(headers, rows);

  const email = String(user.email || '').toLowerCase().trim();
  if (!email) throw new Error('email obrigatório');

  const idx = objs.findIndex(u => String(u.email || '').toLowerCase() === email);
  const lock = LockService.getDocumentLock();
  lock.waitLock(30000);

  try {
    if (idx >= 0) {
      const row = idx + 2;
      const before = objs[idx];

      // Atualiza campos permitidos (inclui reset/primeiro acesso)
      const patch = {
        nome: user.nome ?? before.nome,
        role: user.role ?? before.role,
        area: user.area ?? before.area,
        active: user.active ?? before.active,
        canDelete: user.canDelete ?? before.canDelete,
        passwordHash: user.passwordHash ?? before.passwordHash,

        // novos campos (reset / primeiro acesso)
        mustChangePassword: user.mustChangePassword ?? before.mustChangePassword,
        resetCodeHash: user.resetCodeHash ?? before.resetCodeHash,
        resetCodeExpiresAt: user.resetCodeExpiresAt ?? before.resetCodeExpiresAt,
      };

      Object.keys(patch).forEach(k => {
        if (!map[k]) return; // só grava se a coluna existir na planilha
        sh.getRange(row, map[k]).setValue(patch[k]);
      });

      _log(actorEmail || 'system', 'USER_UPDATE', 'USER', email, before, { ...before, ...patch });
      return { email, ...patch };
    } else {
      const rowObj = {
        email,
        nome: String(user.nome || ''),
        role: String(user.role || 'USER').toUpperCase(),
        area: String(user.area || ''),
        active: user.active ?? true,
        canDelete: user.canDelete ?? false,
        passwordHash: String(user.passwordHash || ''),

        // novos campos (reset / primeiro acesso)
        mustChangePassword: user.mustChangePassword ?? false,
        resetCodeHash: String(user.resetCodeHash || ''),
        resetCodeExpiresAt: String(user.resetCodeExpiresAt || ''),
      };

      sh.appendRow(headers.map(h => rowObj[h] !== undefined ? rowObj[h] : ''));
      _log(actorEmail || 'system', 'USER_CREATE', 'USER', email, null, rowObj);
      return rowObj;
    }
  } finally {
    lock.releaseLock();
  }
}

function usersSetActive(email, active, actorEmail) {
  const sh = _sheet(SHEETS.USERS);
  const map = _headerMap(sh);
  const { headers, rows } = _readAll(sh);
  const objs = _rowsToObjects(headers, rows);

  const e = String(email || '').toLowerCase().trim();
  const idx = objs.findIndex(u => String(u.email || '').toLowerCase() === e);
  if (idx < 0) throw new Error('Usuário não encontrado');

  const row = idx + 2;
  const before = objs[idx];

  const lock = LockService.getDocumentLock();
  lock.waitLock(30000);
  try {
    if (map.active) sh.getRange(row, map.active).setValue(!!active);
    _log(actorEmail || 'system', 'USER_ACTIVE', 'USER', e, before, { ...before, active: !!active });
    return { ...before, active: !!active };
  } finally {
    lock.releaseLock();
  }
}

/* LOOKUPS */
function lookupsList() {
  const sh = _sheet(SHEETS.LOOKUPS);
  const { headers, rows } = _readAll(sh);
  const objs = _rowsToObjects(headers, rows)
    .filter(x => String(x.active).toUpperCase() === 'TRUE')
    .sort((a, b) => Number(a.order || 9999) - Number(b.order || 9999));

  const grouped = {};
  objs.forEach(x => {
    const cat = String(x.category || '').toUpperCase();
    if (!grouped[cat]) grouped[cat] = [];
    grouped[cat].push(String(x.value || '').trim());
  });

  return grouped;
}

function lookupsUpsert(item) {
  const category = String(item.category || '').toUpperCase().trim();
  const value = String(item.value || '').trim();
  const order = Number(item.order || 9999);

  if (!category || !value) throw new Error('category/value obrigatórios');

  const sh = _sheet(SHEETS.LOOKUPS);
  const map = _headerMap(sh);
  const { headers, rows } = _readAll(sh);
  const objs = _rowsToObjects(headers, rows);

  const idx = objs.findIndex(x =>
    String(x.category || '').toUpperCase() === category &&
    String(x.value || '').trim().toLowerCase() === value.toLowerCase()
  );

  const lock = LockService.getDocumentLock();
  lock.waitLock(30000);
  try {
    if (idx >= 0) {
      const row = idx + 2;
      const before = objs[idx];
      sh.getRange(row, map.active).setValue(true);
      if (map.order) sh.getRange(row, map.order).setValue(order);
      _log('system', 'LOOKUP_UPDATE', 'LOOKUP', category + ':' + value, before, { ...before, active: true, order });
    } else {
      const rowArr = headers.map(h => {
        if (h === 'category') return category;
        if (h === 'value') return value;
        if (h === 'active') return true;
        if (h === 'order') return order;
        return '';
      });
      sh.appendRow(rowArr);
      _log('system', 'LOOKUP_ADD', 'LOOKUP', category + ':' + value, null, { category, value, active: true, order });
    }
  } finally {
    lock.releaseLock();
  }

  return lookupsList();
}

function lookupsRename(category, oldValue, newValue, actorEmail) {
  const cat = String(category || '').toUpperCase().trim();
  const oldV = String(oldValue || '').trim();
  const newV = String(newValue || '').trim();
  if (!cat || !oldV || !newV) throw new Error('category/oldValue/newValue obrigatórios');

  const sh = _sheet(SHEETS.LOOKUPS);
  const map = _headerMap(sh);
  const { headers, rows } = _readAll(sh);
  const objs = _rowsToObjects(headers, rows);

  const idx = objs.findIndex(x =>
    String(x.category || '').toUpperCase() === cat &&
    String(x.value || '').trim().toLowerCase() === oldV.toLowerCase()
  );
  if (idx < 0) throw new Error('Lookup não encontrado');

  const row = idx + 2;
  const before = objs[idx];

  const lock = LockService.getDocumentLock();
  lock.waitLock(30000);
  try {
    sh.getRange(row, map.value).setValue(newV);
    _log(actorEmail || 'system', 'LOOKUP_RENAME', 'LOOKUP', `${cat}:${oldV}`, before, { ...before, value: newV });
  } finally {
    lock.releaseLock();
  }

  return lookupsList();
}

/* TASKS */
function tasksList() {
  const sh = _sheet(SHEETS.TASKS);
  const { headers, rows } = _readAll(sh);
  const objs = _rowsToObjects(headers, rows);
  return objs.filter(t => !t.deletedAt);
}

function tasksCreate(task) {
  const sh = _sheet(SHEETS.TASKS);
  const { headers } = _readAll(sh);
  const id = Utilities.getUuid();

  const now = _nowIso();
  const rowObj = Object.assign({}, task, { id });

  // garante colunas mínimas
  if (!rowObj.createdAt) rowObj.createdAt = now;
  if (!rowObj.updatedAt) rowObj.updatedAt = now;
  if (!rowObj.deletedAt) rowObj.deletedAt = '';
  if (!rowObj.deletedBy) rowObj.deletedBy = '';

  const lock = LockService.getDocumentLock();
  lock.waitLock(30000);
  try {
    sh.appendRow(headers.map(h => rowObj[h] !== undefined ? rowObj[h] : ''));
  } finally {
    lock.releaseLock();
  }

  return rowObj;
}

function tasksUpdate(id, patch) {
  id = String(id || '').trim();
  if (!id) throw new Error('id obrigatório');

  const sh = _sheet(SHEETS.TASKS);
  const map = _headerMap(sh);
  const { headers, rows } = _readAll(sh);
  const objs = _rowsToObjects(headers, rows);

  const idx = objs.findIndex(t => String(t.id) === id && !t.deletedAt);
  if (idx < 0) throw new Error('Task não encontrada');

  const row = idx + 2;
  const before = objs[idx];
  const after = { ...before, ...patch };

  const lock = LockService.getDocumentLock();
  lock.waitLock(30000);
  try {
    Object.keys(patch || {}).forEach(k => {
      if (!map[k]) return;
      sh.getRange(row, map[k]).setValue(patch[k]);
    });
  } finally {
    lock.releaseLock();
  }

  return after;
}

function tasksSoftDelete(id, deletedBy) {
  id = String(id || '').trim();
  if (!id) throw new Error('id obrigatório');

  const sh = _sheet(SHEETS.TASKS);
  const map = _headerMap(sh);
  const { headers, rows } = _readAll(sh);
  const objs = _rowsToObjects(headers, rows);

  const idx = objs.findIndex(t => String(t.id) === id && !t.deletedAt);
  if (idx < 0) throw new Error('Task não encontrada');

  const row = idx + 2;
  const before = objs[idx];
  const patch = {
    deletedAt: _nowIso(),
    deletedBy: String(deletedBy || ''),
  };

  const lock = LockService.getDocumentLock();
  lock.waitLock(30000);
  try {
    if (map.deletedAt) sh.getRange(row, map.deletedAt).setValue(patch.deletedAt);
    if (map.deletedBy) sh.getRange(row, map.deletedBy).setValue(patch.deletedBy);
  } finally {
    lock.releaseLock();
  }

  return { ...before, ...patch };
}